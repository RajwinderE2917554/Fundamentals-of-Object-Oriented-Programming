Task-1:

Suppose you are working on a geometry library that deals with different types of geometric shapes, including circles, rectangles, and triangles. 
Each shape has common properties like area and perimeter, but also specific attributes such as radius for circles, length and width for rectangles, and side lengths for triangles.

•	Develop a class hierarchy for geometric shapes using inheritance in C++.
•	Explain how you would utilize inheritance and polymorphism to implement algorithms for calculating area and perimeter that are specific to each type of shape

#include <iostream>
#include <cmath>

using namespace std;

// Inheritance allows derived shape classes (Circle, Rectangle, etc.) to inherit common methods from a base Shape class, such as area() and perimeter(). Polymorphism ensures that the correct area and perimeter calculations specific to each shape are executed at runtime, using the overridden methods.

class Shape {
public:
    double area() {
        return 0.0;
    }

    double perimeter() {
        return 0.0;
    }
};

class Circle : public Shape {
private:
    double radius;

public:
    Circle(double r) {
        radius = r;
    }

    double area() {
        return M_PI * radius * radius;
    }

    double perimeter() {
        return 2 * M_PI * radius;
    }

    double getradius() {
        return radius;
    }
};

class Rectangle : public Shape {
private:
    double length;
    double width;

public:
    Rectangle(double l, double w) {
        length = l;
        width = w;
    }

    double area() {
        return length * width;
    }

    double perimeter() {
        return 2 * (length + width);
    }

    double getlength() {
        return length;
    }

    double getwidth() {
        return width;
    }
};

class Triangle : public Shape {
private:
    double side1;
    double side2;
    double side3;

public:
    Triangle(double s1, double s2, double s3) {
        side1 = s1;
        side2 = s2;
        side3 = s3;
    }

    double area() {
        double s = (side1 + side2 + side3) / 2;
        return sqrt(s * (s - side1) * (s - side2) * (s - side3));
    }

    double perimeter() {
        return side1 + side2 + side3;
    }

    double getside1() {
        return side1;
    }

    double getside2() {
        return side2;
    }

    double getside3() {
        return side3;
    }
};

int main() {
    Circle circle(5);
    Rectangle rectangle(4, 6);
    Triangle triangle(3, 4, 5);

    cout << "Circle - Radius: " << circle.getradius() << endl;
    cout << "Circle - Area: " << circle.area() << endl;
    cout << "Circle - Perimeter: " << circle.perimeter() << endl;

    cout << "\nRectangle - Length: " << rectangle.getlength() << ", Width: " << rectangle.getwidth() << endl;
    cout << "Rectangle - Area: " << rectangle.area() << endl;
    cout << "Rectangle - Perimeter: " << rectangle.perimeter() << endl;

    cout << "\nTriangle - Side1: " << triangle.getside1() << ", Side2: " << triangle.getside2() << ", Side3: " << triangle.getside3() << endl;
    cout << "Triangle - Area: " << triangle.area() << endl;
    cout << "Triangle - Perimeter: " << triangle.perimeter() << endl;

    return 0;
}



Task-2:

An operator overloading allows custom behavior to be defined for built-in operators like addition (+), subtraction (-), when we used with user-defined types.
When overloading binary operators as friend functions, external functions can access private members of a class.
Provide examples how binary operator overloading is implemented using friend functions. 

#include <iostream>

using namespace std;

class Point {
private:
    int x, y;

public:
    Point(int x = 0, int y = 0) {
        this->x = x;
        this->y = y;
    }

    friend Point operator+(Point& p1, Point& p2);

    void display() {
        cout << "x: " << x << ", y: " << y << endl;
    }
};

Point operator+(Point& p1, Point& p2) {
    Point temp;
    temp.x = p1.x + p2.x;
    temp.y = p1.y + p2.y;
    return temp;
}

class Complex {
private:
    double real, imaginary;

public:
    Complex(double real = 0.0, double imaginary = 0.0) {
        this->real = real;
        this->imaginary = imaginary;
    }

    friend Complex operator-(Complex& c1, Complex& c2);

    void display() {
        cout << real << " + " << imaginary << "i" << endl;
    }
};

Complex operator-( Complex& c1, Complex& c2) {
    Complex temp;
    temp.real = c1.real - c2.real;
    temp.imaginary = c1.imaginary - c2.imaginary;
    return temp;
}

int main() {
    
    Point p1(2, 3);
    Point p2(4, 5);

    Point p3 = p1 + p2; 

    cout << "Point Example:" << endl;
    p3.display(); 
    cout << endl;

    Complex c1(5.5, 4.5);
    Complex c2(2.5, 1.5);

    Complex c3 = c1 - c2; 

    cout << "Complex Example:" << endl;
    c3.display(); 

    return 0;
}

